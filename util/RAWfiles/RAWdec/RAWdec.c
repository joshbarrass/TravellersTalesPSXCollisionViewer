//////Travellers Tales RAW decompression tool by @Juanmv94////////

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<windows.h>

const unsigned char decoderawfunc[993] = {
    0x8B, 0x44, 0x24, 0x04, 0x81, 0xEC, 0x88, 0x00, 0x00, 0x00, 0x53, 0x55, 0x56, 0x8D, 0x70, 0x0E, 0x8D, 0x84, 0x24, 0x8D, 0x00, 0x00, 0x00, 0x57, 0x8B, 0xBC, 0x24, 0xA0, 0x00, 0x00, 0x00, 0x66, 0xC7, 0x00, 0x00, 0x00, 0x33, 0xC0, 0x8A, 0x06, 0x46, 0x8D, 0x04, 0x85, 0x02, 0x00, 0x00, 0x00, 0x03, 0xC0, 0x8B, 0xC8, 0xC1, 0xE9, 0x08, 0x83, 0xE1, 0x01, 0x75, 0x14, 0x33, 0xC9, 0x03, 0xC0,
    0x8A, 0x0E, 0x46, 0x88, 0x0F, 0x8B, 0xC8, 0xC1, 0xE9, 0x08, 0x47, 0x83, 0xE1, 0x01, 0x74, 0x14, 0x25, 0xFF, 0x00, 0x00, 0x00, 0x75, 0x17, 0x33, 0xC0, 0x8A, 0x06, 0x46, 0x8D, 0x04, 0x41, 0xF6, 0xC4, 0x01, 0x75, 0x0A, 0x33, 0xC9, 0x8A, 0x0E, 0x46, 0x88, 0x0F, 0x47, 0xEB, 0xC2, 0x8D, 0x0C, 0x00, 0x33, 0xED, 0x8B, 0xC1, 0xBB, 0x02, 0x00, 0x00, 0x00, 0xC1, 0xE8, 0x08, 0x83, 0xE0, 0x01,
    0x81, 0xE1, 0xFF, 0x00, 0x00, 0x00, 0x75, 0x12, 0x33, 0xC9, 0x8A, 0x0E, 0x46, 0x8D, 0x0C, 0x48, 0x8B, 0xD1, 0xC1, 0xEA, 0x08, 0x83, 0xE2, 0x01, 0x8B, 0xC2, 0x85, 0xC0, 0x0F, 0x85, 0xFF, 0x00, 0x00, 0x00, 0x03, 0xC9, 0x8B, 0xD9, 0xC1, 0xEB, 0x08, 0x83, 0xE3, 0x01, 0x81, 0xE1, 0xFF, 0x00, 0x00, 0x00, 0x75, 0x10, 0x8A, 0x06, 0x46, 0x8D, 0x0C, 0x43, 0x8B, 0xC1, 0xC1, 0xE8, 0x08, 0x83,
    0xE0, 0x01, 0x8B, 0xD8, 0x8D, 0x04, 0x09, 0x83, 0xC3, 0x04, 0x8B, 0xC8, 0xC1, 0xE9, 0x08, 0x83, 0xE1, 0x01, 0x25, 0xFF, 0x00, 0x00, 0x00, 0x75, 0x10, 0x33, 0xC0, 0x8A, 0x06, 0x46, 0x8D, 0x04, 0x41, 0x8B, 0xC8, 0xC1, 0xE9, 0x08, 0x83, 0xE1, 0x01, 0x85, 0xC9, 0x0F, 0x84, 0x40, 0x01, 0x00, 0x00, 0x03, 0xC0, 0x4B, 0x8B, 0xC8, 0xC1, 0xE9, 0x08, 0x83, 0xE1, 0x01, 0x25, 0xFF, 0x00, 0x00,
    0x00, 0x75, 0x12, 0x33, 0xC0, 0x8A, 0x06, 0x46, 0x8D, 0x04, 0x41, 0x8B, 0xD0, 0xC1, 0xEA, 0x08, 0x83, 0xE2, 0x01, 0x8B, 0xCA, 0x8D, 0x1C, 0x59, 0x8D, 0x4B, 0xF7, 0x85, 0xC9, 0x0F, 0x85, 0x0E, 0x01, 0x00, 0x00, 0xBA, 0x03, 0x00, 0x00, 0x00, 0x03, 0xC0, 0x8B, 0xC8, 0xC1, 0xE9, 0x08, 0x83, 0xE1, 0x01, 0x25, 0xFF, 0x00, 0x00, 0x00, 0x75, 0x10, 0x33, 0xC0, 0x8A, 0x06, 0x46, 0x8D, 0x04,
    0x41, 0x8B, 0xC8, 0xC1, 0xE9, 0x08, 0x83, 0xE1, 0x01, 0x4A, 0x8D, 0x2C, 0x69, 0x79, 0xD9, 0x8A, 0x16, 0x33, 0xC9, 0x8A, 0x4E, 0x01, 0x88, 0x17, 0x88, 0x4F, 0x01, 0x8A, 0x56, 0x02, 0x33, 0xC9, 0x83, 0xC7, 0x04, 0x8A, 0x4E, 0x03, 0x83, 0xC6, 0x04, 0x88, 0x57, 0xFE, 0x88, 0x4F, 0xFF, 0x45, 0x85, 0xED, 0x0F, 0x8C, 0xB8, 0xFE, 0xFF, 0xFF, 0x45, 0x8A, 0x16, 0x33, 0xC9, 0x8A, 0x4E, 0x01,
    0x88, 0x17, 0x88, 0x4F, 0x01, 0x8A, 0x56, 0x02, 0x33, 0xC9, 0x83, 0xC7, 0x04, 0x8A, 0x4E, 0x03, 0x88, 0x57, 0xFE, 0x88, 0x4F, 0xFF, 0x83, 0xC6, 0x04, 0x4D, 0x75, 0xDD, 0xE9, 0x8F, 0xFE, 0xFF, 0xFF, 0x8D, 0x04, 0x09, 0x8B, 0xC8, 0xC1, 0xE9, 0x08, 0x83, 0xE1, 0x01, 0x25, 0xFF, 0x00, 0x00, 0x00, 0x75, 0x10, 0x33, 0xC0, 0x8A, 0x06, 0x46, 0x8D, 0x04, 0x41, 0x8B, 0xC8, 0xC1, 0xE9, 0x08,
    0x83, 0xE1, 0x01, 0x85, 0xC9, 0x0F, 0x84, 0x69, 0x01, 0x00, 0x00, 0x03, 0xC0, 0xBB, 0x03, 0x00, 0x00, 0x00, 0x8B, 0xC8, 0xC1, 0xE9, 0x08, 0x83, 0xE1, 0x01, 0x25, 0xFF, 0x00, 0x00, 0x00, 0x75, 0x12, 0x33, 0xC0, 0x8A, 0x06, 0x46, 0x8D, 0x04, 0x41, 0x8B, 0xD0, 0xC1, 0xEA, 0x08, 0x83, 0xE2, 0x01, 0x8B, 0xCA, 0x85, 0xC9, 0x74, 0x3A, 0x33, 0xDB, 0x8A, 0x1E, 0x46, 0x85, 0xDB, 0x75, 0x2E,
    0x03, 0xC0, 0x8B, 0xC8, 0xC1, 0xE9, 0x08, 0x83, 0xE1, 0x01, 0x25, 0xFF, 0x00, 0x00, 0x00, 0x75, 0x10, 0x33, 0xC0, 0x8A, 0x06, 0x46, 0x8D, 0x04, 0x41, 0x8B, 0xC8, 0xC1, 0xE9, 0x08, 0x83, 0xE1, 0x01, 0x85, 0xC9, 0x0F, 0x84, 0xAD, 0x01, 0x00, 0x00, 0xE9, 0x02, 0xFE, 0xFF, 0xFF, 0x83, 0xC3, 0x08, 0x03, 0xC0, 0x8B, 0xC8, 0xC1, 0xE9, 0x08, 0x83, 0xE1, 0x01, 0x25, 0xFF, 0x00, 0x00, 0x00,
    0x75, 0x12, 0x33, 0xC0, 0x8A, 0x06, 0x46, 0x8D, 0x04, 0x41, 0x8B, 0xD0, 0xC1, 0xEA, 0x08, 0x83, 0xE2, 0x01, 0x8B, 0xCA, 0x85, 0xC9, 0x0F, 0x84, 0xD8, 0x00, 0x00, 0x00, 0x03, 0xC0, 0x8B, 0xC8, 0xC1, 0xE9, 0x08, 0x83, 0xE1, 0x01, 0x25, 0xFF, 0x00, 0x00, 0x00, 0x75, 0x10, 0x33, 0xC0, 0x8A, 0x06, 0x46, 0x8D, 0x04, 0x41, 0x8B, 0xC8, 0xC1, 0xE9, 0x08, 0x83, 0xE1, 0x01, 0x03, 0xC0, 0x8B,
    0xD1, 0x8B, 0xC8, 0xC1, 0xE9, 0x08, 0x83, 0xE1, 0x01, 0x25, 0xFF, 0x00, 0x00, 0x00, 0x75, 0x10, 0x33, 0xC0, 0x8A, 0x06, 0x46, 0x8D, 0x04, 0x41, 0x8B, 0xC8, 0xC1, 0xE9, 0x08, 0x83, 0xE1, 0x01, 0x85, 0xC9, 0x74, 0x54, 0x8D, 0x2C, 0x00, 0x8B, 0xCD, 0xC1, 0xE9, 0x08, 0x83, 0xE1, 0x01, 0x81, 0xE5, 0xFF, 0x00, 0x00, 0x00, 0x75, 0x12, 0x33, 0xC0, 0x8A, 0x06, 0x46, 0x8D, 0x2C, 0x41, 0x8B,
    0xC5, 0xC1, 0xE8, 0x08, 0x83, 0xE0, 0x01, 0x8B, 0xC8, 0x8D, 0x44, 0x2D, 0x00, 0x8D, 0x14, 0x51, 0x8B, 0xC8, 0x83, 0xCA, 0x04, 0xC1, 0xE9, 0x08, 0x83, 0xE1, 0x01, 0x25, 0xFF, 0x00, 0x00, 0x00, 0x75, 0x10, 0x33, 0xC0, 0x8A, 0x06, 0x46, 0x8D, 0x04, 0x41, 0x8B, 0xC8, 0xC1, 0xE9, 0x08, 0x83, 0xE1, 0x01, 0x85, 0xC9, 0x75, 0x33, 0xEB, 0x09, 0x85, 0xD2, 0x75, 0x2D, 0xBA, 0x01, 0x00, 0x00,
    0x00, 0x03, 0xC0, 0x8B, 0xE8, 0xC1, 0xED, 0x08, 0x83, 0xE5, 0x01, 0x25, 0xFF, 0x00, 0x00, 0x00, 0x75, 0x13, 0x33, 0xC0, 0x8A, 0x06, 0x46, 0x8D, 0x44, 0x45, 0x00, 0x8B, 0xC8, 0xC1, 0xE9, 0x08, 0x83, 0xE1, 0x01, 0x8B, 0xE9, 0x8D, 0x54, 0x55, 0x00, 0x33, 0xC9, 0x8A, 0xEA, 0xC1, 0xEA, 0x08, 0x0B, 0xD1, 0x8B, 0xEA, 0x33, 0xD2, 0x81, 0xE5, 0x00, 0xFF, 0x00, 0x00, 0x8A, 0x16, 0x8B, 0xCD,
    0x8B, 0xEA, 0x8B, 0xD3, 0x0B, 0xE9, 0x8B, 0xCF, 0x2B, 0xCD, 0x46, 0x83, 0xE2, 0x01, 0x49, 0xD1, 0xEB, 0x85, 0xD2, 0x74, 0x08, 0x33, 0xD2, 0x8A, 0x11, 0x41, 0x88, 0x17, 0x47, 0x4B, 0x85, 0xED, 0x74, 0x41, 0x33, 0xD2, 0x83, 0xC7, 0x02, 0x8A, 0x11, 0x83, 0xC1, 0x02, 0x89, 0x54, 0x24, 0x10, 0x8A, 0x51, 0xFF, 0x88, 0x57, 0xFF, 0x8A, 0x54, 0x24, 0x10, 0x88, 0x57, 0xFE, 0x4B, 0x85, 0xDB,
    0x0F, 0x8C, 0xAA, 0xFC, 0xFF, 0xFF, 0x8D, 0x6B, 0x01, 0x8A, 0x59, 0x01, 0x33, 0xD2, 0x8A, 0x11, 0x88, 0x5F, 0x01, 0x88, 0x17, 0x83, 0xC1, 0x02, 0x83, 0xC7, 0x02, 0x4D, 0x75, 0xEB, 0xE9, 0x8D, 0xFC, 0xFF, 0xFF, 0x33, 0xD2, 0x81, 0xE5, 0x00, 0xFF, 0x00, 0x00, 0x8A, 0x11, 0x83, 0xC7, 0x02, 0x8B, 0xCA, 0x0B, 0xCD, 0x4B, 0x88, 0x4F, 0xFE, 0x88, 0x4F, 0xFF, 0x85, 0xDB, 0x0F, 0x8C, 0x6D,
    0xFC, 0xFF, 0xFF, 0x8D, 0x53, 0x01, 0x88, 0x0F, 0x88, 0x4F, 0x01, 0x83, 0xC7, 0x02, 0x4A, 0x75, 0xF5, 0xE9, 0x5A, 0xFC, 0xFF, 0xFF, 0x5F, 0x5E, 0x5D, 0x5B, 0x81, 0xC4, 0x88, 0x00, 0x00, 0x00, 0xC3,
};

FILE *list;

int toBigEndian(unsigned long num) {
	return ((num & 0x000000ff) << 24)|((num & 0x0000ff00) << 8)|((num & 0x00ff0000) >> 8)|((num & 0xff000000) >> 24);
}

void writefile(char* outputname, int size, char* content) {
	char finaloutputname[64];
	sprintf(finaloutputname,"RAWEXTRACT/%s",outputname);
	FILE* output = fopen(finaloutputname, "wb");
	fwrite(content,size,1,output);
	fclose(output);
	fprintf(list,"%s\n",outputname);
}

void getbmp4(char* inp, int uncompressedSize) {
	char outputname[32];
	unsigned char bmp[2166]={0x42,0x4D,0x76,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x76,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x01,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x13,0x0B,0x00,0x00,0x13,0x0B,0x00,0x00,0x10,0x00,0x00,0x00,0x10,0x00,0x00,0x00};
	for (unsigned char x=0;x<4;x++) for (unsigned char y=0;y<4;y++){
		unsigned char *pal=&inp[12+x*48+y*48*4],*bm=&inp[12+768+x*32+y*8192];
		for (int i=0;i<16;i++) {bmp[54+i*4]=pal[2+i*3]; bmp[55+i*4]=pal[1+i*3]; bmp[56+i*4]=pal[0+i*3]; bmp[57+i*4]=0;}	//PAL
		for (int i=0;i<64;i++) memcpy(&bmp[2134-i*32],&bm[i*128],32);													//BM
		for (int i=54+16*4;i<2166;i++) bmp[i]=bmp[i]<<4|bmp[i]>>4;														//Rotate pair of pixels
		sprintf(outputname,"TEX_%03hhu_%03hhu_%03hhu.BMP",inp[0],x,y);
		writefile(outputname,2166,bmp);
	}
}

void getbmp16(char* inp, int uncompressedSize) {
	char outputname[32];
	const unsigned char bmpheader[54]={0x42,0x4D,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x36,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
	unsigned long width=((unsigned int*)inp)[1], height=((unsigned int*)inp)[2], sizebm=width*height*3, sizebmp=sizebm+54;
	unsigned char *bmp=malloc(sizebmp); memcpy(bmp,bmpheader,54);
	memcpy(&bmp[2],&sizebmp,4); memcpy(&bmp[18],&width,4); memcpy(&bmp[22],&height,4); memcpy(&bmp[34],&sizebm,4);
	for (int y=0;y<height;y++) {
		unsigned short *from=(unsigned short*)(inp+16+(height-1-y)*2*width);
		unsigned char *to=bmp+54+y*3*width;
		for (int x=0;x<width;x++) {to[x*3+2]=(from[x]&0x1F)<<3; to[x*3+1]=(from[x]&0x03E0)>>2; to[x*3]=(from[x]&0x7C00)>>7;}
		//to[x]=((from[x]&0x1F)<<11)|((from[x]&0x7C00)>>10)|((from[x]&0x03E0)<<1);
	}
	sprintf(outputname,"TEX_%03hhu.BMP",inp[0]);
	writefile(outputname,sizebmp,bmp);
	free(bmp);
}

int main(int argc, char** argv) {
	puts("Travellers Tales RAW decompression tool by @Juanmv94");
	if (argc<2) {
		puts("Drag file to this executable, or pass it's name as parameter");
		return 0;
	}
	FILE* input = fopen(argv[1], "rb");
	CreateDirectory("RAWEXTRACT",NULL);
	list = fopen("RAWEXTRACT/RAWLIST.TXT", "w");
	char outputname[32];
	unsigned long beuncompressedSize,becompressedSize,uncompressedSize,compressedSize,counter=0;
	fread(&beuncompressedSize, 4, 1, input);
	while (beuncompressedSize!=0xFFFFFFFF) {
		uncompressedSize=toBigEndian(beuncompressedSize);
		fread(&becompressedSize, 4, 1, input);
		compressedSize=toBigEndian(becompressedSize);
		//sprintf(outputname,"%s-%03d.bin",argv[1],++counter);
		printf("Inflating %d->%d\n",compressedSize,uncompressedSize);
		char* i = malloc(compressedSize+0x0E);
		char* o = malloc(uncompressedSize);
		memcpy(i,&beuncompressedSize,4);
		memcpy(i+4,&becompressedSize,4);
		fread(i+8, 6+compressedSize, 1, input);
		((void (*)(void*,void*))decoderawfunc)(i, o);
		switch(o[1]) {
			case 0x01: {	//ALL / ANM
				switch(o[0]) {
					case 0x01: sprintf(outputname,"ENT_%03d.ANM",*(int*)(o+4)); writefile(outputname,uncompressedSize-8,o+8); break;
					case 0x02: sprintf(outputname,"ENT_%03d.ALL",*(int*)(o+4)); writefile(outputname,uncompressedSize-8,o+8); break;
					case 0x03: writefile("TERRAIN.ALL",uncompressedSize-4,o+4); break;
					case 0x04: writefile("TESTTERR.ALL",uncompressedSize-4,o+4); break;
					default: sprintf(outputname,"ENT_FILENO_%03d.BIN",counter); writefile(outputname,uncompressedSize,o);
				}
				break;
			}
			case 0x00: {	//GFX
				switch(*(int*)(o+8)) {
					case 0x0100: getbmp16(o,uncompressedSize); break;
					case 0x0300: if (uncompressedSize==33548) {getbmp4(o,uncompressedSize); break;}
					default: sprintf(outputname,"TEX_FILENO_%03d.TEX",counter); writefile(outputname,uncompressedSize,o);
				}
				break;
			}
			default: sprintf(outputname,"UNK_FILENO%03d.UNK",counter); writefile(outputname,uncompressedSize,o);
		}
		free(i);
		free(o);
		fread(&beuncompressedSize, 4, 1, input);
		counter++;
	}
	fclose(input);
	fclose(list);
	return 0;
}