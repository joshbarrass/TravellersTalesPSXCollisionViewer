<html>
	<head>
		<title>Travellers Tales PSX level collision viewer by @Juanmv94</title>
		<style>
			body { margin: 0; font-family: Arial;}
			canvas { width: 100%; height: 100% }
			center {position:absolute;display: table; height: 100%; width: 100%; color: white;}
			h1 {display: table-cell; vertical-align: middle;}
		</style>
	</head>
	<body>
		<center id="progresscontainer"><h1 id="progress">Loading SaveState file</h1></center>
		<script src="three.min.js"></script>
		<script src="FlyControls.js"></script>
		<script>
			var games = {
				"blsc": {"areasize": 0x34, "polysize":22, "loadobjects":loadobjects, "loadpoly":loadpolyts2, "iniarea": psxetopos(0xb69ec8), "mult":0.025},
				"ts2": {"areasize": 0x34, "polysize":22, "loadobjects":loadobjects, "loadpoly":loadpolyts2, "iniarea": psxetopos(0xb54bb0), "mult":0.05},
				"ts2demo": {"areasize": 0x30, "polysize":22, "loadobjects":loadobjects, "loadpoly":loadpolyts2, "iniarea": psxetopos(0xb43b80), "mult":0.05},
				"ts2proto": {"areasize": 0x30, "polysize":22, "loadobjects":loadobjects, "loadpoly":loadpolyts2, "iniarea": psxetopos(0xb3c748), "mult":0.05},
				"bugs": {"areasize": 0x30, "polysize":16, "loadobjects":loadobjects, "loadpoly":loadpolybugs, "iniarea": psxetopos(0xb334e8), "mult":0.075},
				"bugsdemo": {"areasize": 0x30, "polysize":24, "loadobjects":loadobjects, "loadpoly":loadpolybugs, "iniarea": psxetopos(0xb322f8), "mult":0.075},
				"rascal": {"areasize": 0xC4, "polysize":44, "loadobjects":loadobjectsrascal, "loadpoly":loadpolyrascal, "iniarea": psxetopos(0xb4cd7c), "mult":0.005}
			};
			var urlvars = {};
			var parts = window.location.href.replace(/[?&]+([^=&]+)=([^&]*)/gi, function(m,key,value) {
				urlvars[key] = value;
			});
		
			var mult=games[urlvars["game"]].mult;
			
			var arrayBuffer,array16;
			var oReq = new XMLHttpRequest();
			var progresstring=document.getElementById("progress");
			oReq.open("GET", "SSTATES/"+urlvars["file"], true);
			oReq.responseType = "arraybuffer";
			oReq.onload = function (oEvent) {
			  if ((oReq.readyState != 4) || (oReq.status != 200)) {
				progresstring.innerText="Failed to load "+urlvars["file"];
				return;
			  }
			  
			  arrayBuffer = oReq.response; // Note: not oReq.responseText
			  if (arrayBuffer) {
			    array8u = new Uint8Array(arrayBuffer.slice(2));
				array16 = new Int16Array(arrayBuffer.slice(2));
				array32 = new Int32Array(arrayBuffer.slice(2));
				array32u = new Uint32Array(arrayBuffer.slice(2));
				setTimeout(loaded,50);	//we show loading 100%
			  }
			};
			oReq.onprogress = function(pe) {
			  if (pe.lengthComputable) progresstring.innerText="Loading SaveState file: "+Math.floor(pe.loaded/pe.total*100)+"%";
			}
			oReq.send(null);
			
			function postopsxe(pos) {
				return (pos+11056360).toString(16);
			}
			
			function psxetopos(psxe) {
				return psxe-11056360;
			}
			
			function postoadd(add) {
				return (add+2147483208).toString(16);
			}
			
			function addtopos(add) {
				return add-2147483208;
			}
			
			var blinecolor=new THREE.LineBasicMaterial({color: 0x000000, linewidth: 0.5});
			var glinecolor=new THREE.LineBasicMaterial({color: 0x777777, linewidth: 0.5});
			var colors=[
				new THREE.MeshPhongMaterial({color:0xccffcc, flatShading: true}),	//0= TS2: green toxic, BLSC: toxic, Bugs: normal
				new THREE.MeshPhongMaterial({color:0xaa00ff, flatShading: true}),	//1= TS2: toxic 2, BLSC: toxic with high jump, Bugs: instant death
				new THREE.MeshPhongMaterial({color:0xff00aa, flatShading: true}),	//2= TS2: toxic 3, BLSC: toxic with waves, Bugs: level finish 1
				new THREE.MeshPhongMaterial({color:0x7777ff, flatShading: true}),	//3= TS2: wet, BLSC: ???, Bugs: level finish 2
				new THREE.MeshPhongMaterial({color:0x2222aa, flatShading: true}),	//4= TS2: dirty wet, BLSC: slippery wet, Bugs: toxic
				new THREE.MeshPhongMaterial({color:0xffffaa, flatShading: true}),	//5= TS2: slippery 1, BLSC: slippery 1
				new THREE.MeshPhongMaterial({color:0xffff77, flatShading: true}),	//6= TS2: slippery 2, BLSC: slippery 2
				new THREE.MeshPhongMaterial({color:0xffff00, flatShading: true}),	//7= BLSC: slippery 3
				new THREE.MeshPhongMaterial({color:0xffffff, flatShading: true})];	//def= TS2: normal,  BLSC: normal
			
			
			function loadpolylist(pos) {
				var enabled=array16[pos++];
				if (enabled!=1) return [];
				var count=array16[pos++];
				//console.log("count:"+count);
				var unk=[array16[pos],array16[pos+1],array16[pos+2],array16[pos+3]];
				pos+=4;
				var res=new Array(count);
				for (var i=0;i<count;i++) {
					res[i]=games[urlvars["game"]].loadpoly(pos);
					pos+=games[urlvars["game"]].polysize;
				}
				return res.concat(loadpolylist(pos));
			}
			
			function loadpolylistrascal(pos) {
				var enabled=array16[pos++];
				if (enabled!=1) return [];
				var count=array16[pos++];
				if (count<0 || count>256) return [];
				//console.log("count:"+count);
				var res=new Array(count);
				for (var i=0;i<count;i++) {
					res[i]=games[urlvars["game"]].loadpoly(pos);
					pos+=games[urlvars["game"]].polysize;
				}
				return res;
			}
			
			function loadpolyts2(pos) {
				return {activearea:[array16[pos+0],array16[pos+1],array16[pos+2],array16[pos+3]], pOrigin:[array16[pos+4],array16[pos+5],array16[pos+6]],p2:[array16[pos+7],array16[pos+8],array16[pos+9]],p3:[array16[pos+10],array16[pos+11],array16[pos+12]],p4:[array16[pos+13],array16[pos+14],array16[pos+15]],inclinacion1:[array16[pos+16],array16[pos+18]], bouncing1:array16[pos+17],inclinacion2:[array16[pos+19],array16[pos+21]], bouncing2:array16[pos+20]};
			}
			
			function loadpolybugs(pos) {
				return {unk1:[array16[pos+0],array16[pos+1],array16[pos+2]],pOrigin:[array16[pos+3],array16[pos+4],array16[pos+5]],p2:[array16[pos+6],array16[pos+7],array16[pos+8]],p3:[array16[pos+9],array16[pos+10],array16[pos+11]],unk2:[array16[pos+12],array16[pos+13],array16[pos+14],array16[pos+15]],
				bouncing2:0x7FFF	//bouncing doesn't exist in bugs life, and polygons are single triangles. Set 0x7FFF -> second triangle doesn't exist.
				};
			}
			
			function loadpolyrascal(pos) {
				pos=pos/2;
				return {pOrigin:[array32[pos+0],array32[pos+1],array32[pos+2]],p2:[array32[pos+3],array32[pos+4],array32[pos+5]],p3:[array32[pos+6],array32[pos+7],array32[pos+8]]};
			}
			
			function drawpoly(t,color) {
				var group = new THREE.Group();
				group.info=t;
				var coords1= new Array(3);
				coords1[0]=new Array(3);
				coords1[0][0]=t.pOrigin[0]*mult;
				coords1[0][1]=-t.pOrigin[1]*mult;
				coords1[0][2]=-t.pOrigin[2]*mult;
				coords1[1]= new Array(3);
				coords1[1][0]=(t.pOrigin[0]+t.p2[0])*mult;
				coords1[1][1]=-(t.pOrigin[1]+t.p2[1])*mult;
				coords1[1][2]=-(t.pOrigin[2]+t.p2[2])*mult;
				coords1[2]= new Array(3);
				coords1[2][0]=(t.pOrigin[0]+t.p3[0])*mult;
				coords1[2][1]=-(t.pOrigin[1]+t.p3[1])*mult;
				coords1[2][2]=-(t.pOrigin[2]+t.p3[2])*mult;
				if (t.bouncing2==32767) {
					group.add(drawtriangle(coords1,color,false));
					return group;
				}
				group.add(drawtriangle(coords1,color,true));
				var coords2= new Array(3);
				coords2[0]=new Array(3);
				coords2[0][0]=(t.pOrigin[0]+t.p4[0])*mult;
				coords2[0][1]=-(t.pOrigin[1]+t.p4[1])*mult;
				coords2[0][2]=-(t.pOrigin[2]+t.p4[2])*mult;
				coords2[2]= new Array(3);
				coords2[2][0]=(t.pOrigin[0]+t.p2[0])*mult;
				coords2[2][1]=-(t.pOrigin[1]+t.p2[1])*mult;
				coords2[2][2]=-(t.pOrigin[2]+t.p2[2])*mult;
				coords2[1]= new Array(3);
				coords2[1][0]=(t.pOrigin[0]+t.p3[0])*mult;
				coords2[1][1]=-(t.pOrigin[1]+t.p3[1])*mult;
				coords2[1][2]=-(t.pOrigin[2]+t.p3[2])*mult;
				group.add(drawtriangle(coords2,color,true));
				return group;
			}
			
			function drawpolyrascal(t,color) {
				var group = new THREE.Group();
				group.info=t;
				
				var coords= new Array(3);
				coords[0]=new Array(3);
				coords[0][0]=t.pOrigin[0]*mult;
				coords[0][1]=-t.pOrigin[1]*mult;
				coords[0][2]=-t.pOrigin[2]*mult;
				coords[1]= new Array(3);
				coords[1][0]=t.p2[0]*mult;
				coords[1][1]=-t.p2[1]*mult;
				coords[1][2]=-t.p2[2]*mult;
				coords[2]= new Array(3);
				coords[2][0]=t.p3[0]*mult;
				coords[2][1]=-t.p3[1]*mult;
				coords[2][2]=-t.p3[2]*mult;
				group.add(drawtriangle(coords,color,false));
				return group;
			}
			
			function drawobject(pos32) {
				var category=array8u[(pos32<<2)+46];
				var polylist=loadpolylist(addtopos(array32u[pos32+4])/2);
				var group = new THREE.Group();
				for (var i=0;i<polylist.length;i++) {
					group.add(drawpoly(polylist[i],Math.min(category,8)));
				}
				group.position.x=array32[pos32]*mult/32;
				group.position.y=-array32[pos32+1]*mult/32;
				group.position.z=-array32[pos32+2]*mult/32;
				group.pointer=pos32*4;
				return group;
			}
			
			function drawobjectrascal(pos32) {
				var polylist=loadpolylistrascal(addtopos(array32u[pos32])/2);
				var group = new THREE.Group();
				for (var i=0;i<polylist.length;i++) {
					group.add(drawpolyrascal(polylist[i],8));
				}
				group.position.x=array32[pos32+4]*32*mult;
				group.position.y=-array32[pos32+5]*32*mult;
				group.position.z=-array32[pos32+6]*32*mult;
				group.pointer=pos32*4;
				return group;
			}
			
			function drawtriangle(coords, color, gray) {
				var group = new THREE.Group();
				var vertices = new Float32Array();
				var geom = new THREE.BufferGeometry();
				if (gray) {
					geom.addAttribute('position', new THREE.BufferAttribute(new Float32Array([coords[1][0], coords[1][1], coords[1][2], coords[0][0], coords[0][1], coords[0][2], coords[2][0], coords[2][1], coords[2][2]]),3));
					
					var glgeom=new THREE.BufferGeometry();
					glgeom.addAttribute('position', new THREE.BufferAttribute(new Float32Array([coords[2][0], coords[2][1], coords[2][2], coords[1][0], coords[1][1], coords[1][2]]),3));
					var gline = new THREE.Line(glgeom, glinecolor);
					group.add(gline);
				} else {
					geom.addAttribute('position', new THREE.BufferAttribute(new Float32Array([coords[1][0], coords[1][1], coords[1][2], coords[0][0], coords[0][1], coords[0][2], coords[2][0], coords[2][1], coords[2][2], coords[1][0], coords[1][1], coords[1][2]]),3));
				}
				var line = new THREE.Line(geom, blinecolor);
				group.add(line);
				var mesh = new THREE.Mesh(geom, colors[color]);
				group.add(mesh);
				return group;
			}

			var scene = new THREE.Scene();
			scene.background = new THREE.Color(0x7777ff);
			var camera = new THREE.PerspectiveCamera( 50, window.innerWidth/window.innerHeight, 0.1, 10000 );
			
			scene.add(new THREE.AmbientLight(0xffffff, 1));
			var light = new THREE.HemisphereLight(0xffffff, 0x505050, -0.5);
			light.position.set(1000, 10000, 2000);
			scene.add( light );

			var renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
			
			function setWireframe(obj, wireframe) {
				if (obj instanceof THREE.Mesh) {
					  obj.visible = !wireframe;
					  return;
				}
			  obj.children.forEach(function(child) {
				setWireframe(child, wireframe);
			  });
			}
			
			function onDocumentMouseDown( event ) 
			{
				if (event.button!=0) {
					setWireframe(area,false);
					return;
				}
				var raycaster = new THREE.Raycaster(),
				mouse = new THREE.Vector2(),
				intersects;
				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
				raycaster.setFromCamera(mouse, camera);
				intersects = raycaster.intersectObjects(area.children, true);
				if (intersects.length > 0){
					var obj=intersects[0].object.parent.parent.parent
					if (obj==selectedObj) {
					 setWireframe(area,false);
					 selectedObj=null;
					} else {
						setWireframe(area,true);
						setWireframe(obj,false);
						selectedObj=obj;
						console.log("Selected object at: 0x"+postoadd(obj.pointer)+", emu: 0x"+postopsxe(obj.pointer));
						//poly=intersects[0].object.parent.parent;
						//console.log("Clicked polygon information:");
						//console.log(poly.info);
					}
					
				} else {
					setWireframe(area,false);
					selectedObj=null;
				}
			}
			
			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			
			function loadobjects(inipos) {
				var area=new THREE.Group();
				while (array32u[inipos/4+4]!=0) {
					area.add(drawobject(inipos/4));
					inipos+=games[urlvars["game"]].areasize;
				}
				return area;
			}
			
			function loadobjectsrascal(inipos) {
				var area=new THREE.Group();
				while (array32u[inipos/4]>0) {
					area.add(drawobjectrascal(inipos/4));
					inipos+=games[urlvars["game"]].areasize;
				}
				return area;
			}
			
			var selectedObj=null;
			var area=null;
			function loaded() {
				document.getElementById("progresscontainer").style.display="none";
				var iniarea=games[urlvars["game"]].iniarea;
				area=games[urlvars["game"]].loadobjects(iniarea);
				scene.add(area);
				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				window.addEventListener( 'resize', onWindowResize, false );

				camera.rotation.x = Math.PI;
				camera.rotation.z = Math.PI;
				camera.rotation.y = -Math.PI/4;

				var controls = new THREE.FlyControls( camera, renderer.domElement );
				var t=performance.now();
				var animate = function () {
					requestAnimationFrame( animate );
					var newt=performance.now();
					controls.update(newt-t);
					t=newt;
					renderer.render( scene, camera );
				};

				animate();
			}
		</script>
	</body>
</html>